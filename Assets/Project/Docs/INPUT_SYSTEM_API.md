# ðŸŽ® Antigravity Input System API

> **Version**: 2.0 (Streamlined)
> **Dependencies**: Unity Input System Package (New)

## Overview

The Antigravity Input System is a **decoupled, event-driven wrapper** around Unity's Input System. It provides a fluent API for binding actions, supports complex input patterns (Combos, Buffering, Hold/Tap), and separates input _detection_ from input _logic_.

### Key Features

- **Fluent Builder**: Bind inputs in one line of readable code.
- **Input Router**: Central hub that manages the Input Map and dispatches events.
- **Combos**: Built-in support for fighting-game style combos (e.g., A -> A -> B).
- **Buffering**: "Early press" buffering for tighter controls (e.g., pressing Jump slightly before landing).
- **Contextual**: Bindings can be conditional (e.g., "Only jump if not in a menu").

---

## ðŸš€ Quick Start

### 1. Setup

Ensure your Player object has the following components:

- **`InputRouter`**: The core component.
- **`PlayerInputHandler`** (Your Script): Where you define your logic.

### 2. Binding Inputs

In your `PlayerInputHandler`, use the `RegisterInputs` method to bind actions.

```csharp
public void RegisterInputs(InputBuilder builder)
{
    // 1. Simple Button (Press/Release)
    builder.Bind(builder.Actions.Jump)
           .Press(() => _jumpRequested = true)
           .Release(() => _jumpRequested = false)
           .Register();

    // 2. Value (Movement/Look)
    builder.Bind(builder.Actions.Move)
           .To<Vector2>(v => _moveInput = v);

    // 3. Hold vs Tap
    builder.Bind(builder.Actions.Interact)
           .Hold(0.5f)
           .Tap(() => Debug.Log("Interacted!"))
           .To(() => Debug.Log("Holding Interaction..."))
           .Register();
}
```

---

## ðŸ“š Core Concepts

### InputRouter

The `InputRouter` is the "brain". It owns the generated `InputMap` (Unity's C# class) and maps `InputAction` events to your custom Commands.

- **Best Practice**: Don't access `InputRouter` directly from gameplay logic. Use it only to bind inputs during initialization.

### InputBuilder

The `InputBuilder` is a helper class that makes binding easy. It uses a **Fluent Interface** pattern.

#### `Bind(Action)`

Starts a binding chain.

- `.To(Action)`: Simple "Performed" callback.
- `.To<T>(Action<T>)`: Value callback (Vector2, float).
- `.Press(Action)`: "Started" callback (Button Down).
- `.Release(Action)`: "Canceled" callback (Button Up).

#### Advanced Bindings

- `.Hold(duration)`: Distinguishes between a quick Tap and a long Hold.
- `.Buffer(duration, gate, action)`: Buffers an input if `gate()` returns false (e.g., in air), and executes it if `gate()` becomes true within `duration`.
- `.When(condition)`: Only executes the command if `condition()` is true.

---

## ðŸ¥Š Combo System

The system includes a lightweight Combo Recognizer.

### Setup

1.  Define your combos in a `ComboDefinition` (or code).
2.  Use `ComboRecognizer` to track inputs.

_(See `ComboRecognizer.cs` for implementation details)_

---

## ðŸ“‚ File Structure

- **`Core/`**: Essential system scripts (`InputRouter`, `InputBufferService`).
- **`Commands/`**: Logic for different input types (`ButtonCommand`, `ValueCommand`, `HoldTapReleaseCommand`).
- **`Combos/`**: Combo recognition logic.
- **`InputBuilder.cs`**: The main API you interact with.

---

## ðŸ”§ Extending the System

### Custom Commands

To add new input behaviors (e.g., "Double Tap"), implement `IInputCommand`:

```csharp
public class DoubleTapCommand : IInputCommand
{
    public void Execute(InputAction.CallbackContext context)
    {
        // Your custom logic here
    }
}
```

Then bind it manually:

```csharp
router.Bind(action, new DoubleTapCommand(...));
```

---

## â™»ï¸ Reusing in Other Projects

This system is designed to be **100% portable**. However, because it bridges Unity's generated Input Class (which changes per project) to generic code, there are **3 specific files** you must update when moving to a new project.

### 1. The Bridge (`InputRouter.cs`)

This file connects your project-specific `InputMap` (generated by Unity) to the generic system.

**Steps:**

1.  Open `InputRouter.cs`.
2.  Change `InputMap` to your project's generated class name (e.g., `SimpleGameInputs`).
3.  Implement the correct interface (e.g., `SimpleGameInputs.IGameplayActions`).
4.  **Delete unused Dispatch methods**. Use only what you need!

**Example for a Simple Game:**

```csharp
// 1. Change Class Type
public class InputRouter : MonoBehaviour, SimpleGameInputs.IGameplayActions
{
    // ... setup code ...

    // 2. Keep ONLY the inputs you need
    public void OnMove(InputAction.CallbackContext ctx) => Dispatch(ctx);
    public void OnJump(InputAction.CallbackContext ctx) => Dispatch(ctx);
    public void OnInteract(InputAction.CallbackContext ctx) => Dispatch(ctx);
}
```

### 2. The Helper (`InputBuilder.cs`)

This builder needs to know what actions represent "Gameplay" or "UI" in your new project so it can give you autocomplete.

**Steps:**

1.  Open `InputBuilder.cs`.
2.  Update the `Actions` property to return your new Action Map type.

**Example:**

```csharp
public class InputBuilder
{
    // Change return type to your new map class
    public SimpleGameInputs.GameplayActions Actions => _router.Gameplay;
}
```

### 3. The Vocabulary (`ComboTypes.cs` / `GameInputContext.cs`)

These files define the "language" of your specific game.

- **`ComboTypes.cs`**: If your game isn't a fighting game, you might not need this, or you might rename `One/Two` to `Punch/Kick`.
- **`GameInputContext.cs`**: Remove any game-specific flags (e.g., `HackMenuHeld`) that don't apply to your new project.

**That's it!** The rest of the system (`Core/`, `Commands/`) requires **zero changes** and will work immediately. ðŸš€
